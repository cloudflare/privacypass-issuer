// Generated by dts-bundle-generator v9.5.1

import { Performance as Performance$1, R2Bucket as R2Bucket$1, R2GetOptions as R2GetOptions$1, R2HTTPMetadata as R2HTTPMetadata$1, R2ListOptions as R2ListOptions$1 } from '@cloudflare/workers-types/2023-07-01';
import { Breadcrumb } from '@sentry/types';
import { WorkerEntrypoint, WorkflowEntrypoint, WorkflowEvent, WorkflowStep } from 'cloudflare:workers';
import { CounterType, HistogramType, RegistryType } from 'promjs-plus';

// Copyright (c) 2023 Cloudflare, Inc.
// SPDX-License-Identifier: Apache-2.0
declare global {
	// RELEASE is statically replaced at compile time by esbuild.
	// See scripts/build.js for more information.
	const RELEASE: string;
	// blindrsa requires these interface to be in scope
	// while they are available in
	interface RsaHashedKeyGenParams {
		hash: string | object;
		modulusLength: number;
		name: string;
		publicExponent: Uint8Array;
	}
	type KeyFormat = "jwk" | "pkcs8" | "raw" | "spki";
	type KeyUsage = "encrypt" | "decrypt" | "sign" | "verify" | "deriveKey" | "deriveBits" | "wrapKey" | "unwrapKey";
	// privacypass requires these interface to be in scope
	interface Algorithm {
		name: string;
	}
	type AlgorithmIdentifier = Algorithm | string;
	type HashAlgorithmIdentifier = AlgorithmIdentifier;
	interface RsaHashedImportParams extends Algorithm {
		hash: HashAlgorithmIdentifier;
	}
	interface Array<T> {
		filterMap<R>(f: (t: T) => R | null): R[];
	}
}
export interface Bindings {
	DIRECTORY_CACHE_MAX_AGE_SECONDS: string | null;
	USE_CACHE_API: string | null;
	ENVIRONMENT: string;
	SERVICE: string;
	SENTRY_ACCESS_CLIENT_ID: string | null;
	SENTRY_ACCESS_CLIENT_SECRET: string | null;
	SENTRY_DSN: string | null;
	SENTRY_SAMPLE_RATE: string | null;
	ISSUANCE_KEYS: R2Bucket$1;
	PERFORMANCE: Performance$1 | null;
	VERSION_METADATA: ScriptVersion;
	ROTATION_CRON_STRING: string | null;
	KEY_LIFESPAN_IN_MS: string;
	KEY_NOT_BEFORE_DELAY_IN_MS: string;
	MINIMUM_FRESHEST_KEYS: string | null;
	LOGGING_SHIM_TOKEN: string | null;
	WSHIM_SOCKET: Fetcher | null;
	WSHIM_ENDPOINT: string | null;
	BACKUPS_CRON_STRING: string | null;
	BACKUPS_SERVICE_ACCOUNT_KEY: string | null;
	BACKUPS_BUCKET_NAME: string | null;
	KEY_BACKUP_WF: Workflow;
}
export type NonNullableFields<T> = {
	[P in keyof T]: T[P] extends infer U | null ? U : T[P];
};
export type UncheckedBindings = Partial<NonNullableFields<Bindings>>;
export type CacheElement<T> = {
	value: T;
	expiration: Date;
};
export interface ReadableCache {
	read<T>(key: string, setValFn: (key: string) => Promise<CacheElement<T>>): Promise<T>;
}
declare class CachedR2Object {
	data?: Uint8Array | undefined;
	checksums: R2Checksums;
	customMetadata?: Record<string, string>;
	etag: string;
	httpEtag: string;
	httpMetadata?: R2HTTPMetadata$1;
	key: string;
	size: number;
	uploaded: Date;
	version: string;
	constructor(object: R2Object, data?: Uint8Array | undefined);
}
declare class CachedR2Objects {
	delimitedPrefixes: string[];
	objects: CachedR2Object[];
	truncated: boolean;
	constructor(objects: R2Objects);
}
export interface CachedR2BucketOptions {
	shouldUseCache?: boolean;
}
declare class CachedR2Bucket {
	private cache;
	private ttl_in_ms;
	private readonly bucket;
	private readonly prefix;
	constructor(ctx: Context, bucket: R2Bucket$1, cache: ReadableCache, prefix?: string, ttl_in_ms?: number);
	private shouldUseCache;
	private addPrefix;
	head(key: string, options?: CachedR2BucketOptions): Promise<CachedR2Object | null>;
	list(options?: R2ListOptions$1 & CachedR2BucketOptions): Promise<CachedR2Objects>;
	get(key: string, options?: R2GetOptions$1 & CachedR2BucketOptions): Promise<CachedR2Object | null>;
	put(...args: Parameters<typeof R2Bucket$1.prototype.put>): ReturnType<typeof R2Bucket$1.prototype.put>;
	delete(...args: Parameters<typeof R2Bucket$1.prototype.delete>): ReturnType<typeof R2Bucket$1.prototype.delete>;
}
export interface Logger {
	captureException(err: Error): void;
	addBreadcrumb(breadcrumb: Breadcrumb): void;
	setTag(key: string, value: string): void;
	setSampleRate(sampleRate: number): void;
	info(category: string, message: string, data?: {
		[key: string]: any;
	}): void;
}
declare class WshimLogger {
	private logs;
	private sampleRate;
	private wshimOptions?;
	private readonly defaultFields;
	constructor(request: Request, env: Bindings, logger: Logger, sampleRate?: number);
	private shouldLog;
	log(...msg: unknown[]): void;
	error(...msg: unknown[]): void;
	flushLogs(): Promise<void>;
}
declare class MetricsRegistry {
	registry: RegistryType;
	asyncRetriesTotal: CounterType;
	directoryCacheMissTotal: CounterType;
	erroredRequestsTotal: CounterType;
	issuanceKeyErrorTotal: CounterType;
	issuanceRequestTotal: CounterType;
	lastRotationTimestamp: CounterType;
	keyClearTotal: CounterType;
	requestsDurationMs: HistogramType;
	requestsTotal: CounterType;
	r2RequestsDurationMs: HistogramType;
	signedTokenTotal: CounterType;
	cacheRefreshed: CounterType;
	defaultLabels: {
		env: string;
		service: string;
		version: string;
	};
	wshimOptions?: WshimOptions;
	constructor(env: Bindings, logger: Logger);
	private createCounter;
	private createGauge;
	private createHistogram;
	private create;
	/**
	 * Publishes metrics to the workers metrics API
	 * This function is a no-op in test and wrangler environements
	 */
	publish(): Promise<void>;
}
export interface ServiceInfo {
	url: string;
	route: string;
	service: string;
}
export interface BaseRpcOptions {
	prefix?: string;
	serviceInfo: ServiceInfo;
}
export interface IssueOptions extends BaseRpcOptions {
	tokenRequest: ArrayBuffer;
	contentType: string;
}
declare class WshimOptions {
	readonly token: string;
	readonly socket: Fetcher;
	readonly endpoint: string;
	static init(env: Bindings, endpoint: "log" | "prometheus", logger: Logger): WshimOptions | undefined;
	private constructor();
	flush(body: BodyInit): Promise<void>;
}
export type WaitUntilFunc = (p: Promise<unknown>) => void;
declare class Context {
	readonly env: Bindings;
	private readonly _waitUntil;
	readonly logger: Logger;
	readonly metrics: MetricsRegistry;
	readonly wshimLogger: WshimLogger;
	readonly prefix?: string | undefined;
	hostname: string;
	startTime: number;
	private promises;
	bucket: {
		ISSUANCE_KEYS: CachedR2Bucket;
	};
	performance: Performance;
	serviceInfo?: ServiceInfo;
	key_id?: number;
	cacheSettings?: {
		maxAgeSeconds: number;
	};
	constructor(request: Request, env: Bindings, _waitUntil: WaitUntilFunc, logger: Logger, metrics: MetricsRegistry, wshimLogger: WshimLogger, prefix?: string | undefined);
	/**
	 *
	 * Flush out any pending metrics/logs that were scheduled via waitUntil.
	 */
	postProcessing(): Promise<void>;
	isTest(): boolean;
	/**
	 * Registers async tasks with the runtime, tracks them internally and adds error reporting for uncaught exceptions
	 * @param p - Promise for the async task to track
	 */
	waitUntil(p: Promise<unknown>): void;
	/**
	 * Waits for promises to complete in the order that they were registered.
	 *
	 * @remark
	 * It is important to wait for the promises in the array to complete sequentially since new promises created by async tasks may be added to the end of the array while this function runs.
	 */
	waitForPromises(): Promise<void>;
}
export declare class KeyBackupWorkflow extends WorkflowEntrypoint<UncheckedBindings> {
	run(_event: WorkflowEvent<unknown>, step: WorkflowStep): Promise<void>;
}
declare class HTTPError extends Error {
	status: number;
	constructor(message?: string, status?: number);
}
export declare class InvalidTokenTypeError extends HTTPError {
	static CODE: string;
	code: string;
	constructor(message?: string);
}
export declare class InvalidBatchedTokenTypeError extends HTTPError {
	static CODE: string;
	code: string;
	constructor(message?: string);
}
export declare class BadTokenKeyRequestedError extends HTTPError {
	static CODE: string;
	code: string;
	constructor(message?: string);
}
export declare class MismatchedTokenKeyIDError extends HTTPError {
	static CODE: string;
	code: string;
	constructor(message?: string);
}
/**
 * The response returned by the `issue()` function.
 *
 * The `notBefore` field is temporarily included to allow the
 * calculation of the expiration date.
 */
export interface IssueResponse {
	serialized: Uint8Array;
	status: number;
	responseContentType: string;
	notBefore?: number;
}
export declare const issue: (ctx: Context, buffer: ArrayBuffer, domain: string, contentType: string) => Promise<IssueResponse>;
export declare const handleTokenRequest: (ctx: Context, request: Request) => Promise<Response>;
export declare const handleSingleTokenRequest: (ctx: Context, buffer: ArrayBuffer, domain: string) => Promise<IssueResponse>;
export declare const handleBatchedTokenRequest: (ctx: Context, buffer: ArrayBuffer, domain: string) => Promise<IssueResponse>;
export declare const handleHeadTokenDirectory: (ctx: Context, request: Request) => Promise<Response>;
export declare const handleTokenDirectory: (ctx: Context, request: Request) => Promise<Response>;
export declare const handleRotateKey: (ctx: Context, _request: Request) => Promise<Response>;
export declare const handleClearKey: (ctx: Context, _request: Request) => Promise<Response>;
export declare class IssuerHandler extends WorkerEntrypoint<Bindings> {
	private context;
	fetch(request: Request): Promise<Response>;
	tokenDirectory(opts: BaseRpcOptions): Promise<Response>;
	issue(opts: IssueOptions): Promise<IssueResponse>;
	rotateKey(opts: BaseRpcOptions): Promise<Uint8Array>;
	clearKey(opts: BaseRpcOptions): Promise<string[]>;
	private withMetrics;
}
declare const _default: {
	fetch(request: Request, env: UncheckedBindings, ctx: ExecutionContext): Promise<Response>;
	scheduled(event: ScheduledEvent, env: UncheckedBindings, ctx: ExecutionContext): Promise<void>;
};

export {
	_default as default,
};

export {};
